## План
![[Pasted image 20220930090306.png]]
![[Pasted image 20220930090403.png]]

 **Основные функции ОС**
  - Существование ресурсов
  - Использование ресурсов
  - Распределение ресурсов между пользователям системы

Уровни взаимодействия между пользователем и железом
![[Pasted image 20220930091115.png]]

**Файловая система** 
 - организация блоков данных
 - файл - базовая сущность ФС; набора байт, ассоциирующийся с набором атрибутов
![[Pasted image 20220930092713.png]] 


Файловая система Linux
 **Процесс** - базовая единица ОС
 У процесса есть контекст: **user context** (команды, код, данные), **system context** (id, доступы, открытые файлы и i/o потоки), **hardware context** (состояние регистров процессора, точка остановы и тд)


**Процессы и потоки**
У каждого процесса свои уникальные сегменты памяти и своя личная адресация.
В рамках одного процесса можно форкать несколько потоков, являющихся частями этого процесса; у этих потоков общие переменные и глобальная адресация.

**Файловая система Linux**
![[Pasted image 20220930093147.png]]


 - > - перенаправление потока вывода (затирает файл)
 - >> - перенаправление потока вывода в конец файла
 - | - перенаправление потока вывода между командами
 - & - запускает процесс на фоне (умирают при закрытии терминала)
 - nohup (в начале команды) - процесс игнорирует stigterm от материнского терминала, из которого был запущен фоновый процесс


## Язык bash
 - переменные, массивы
 - цикл for
 - условие if, elif, else

## Работа с облаком (vk cloud)

 - создание vm с возможностью внешнего подключения

 - скачиваем ключ в формате .pem
![[Pasted image 20220930155911.png]]

**добавление нового пользователя**
`sudo adduser user_name`
... задаются пароли на всякие действия и Y/N

в пути `/erc/ssh` есть файлик `ssh_config` и `sshd_config`, в котором мы можем менять настройки подключения к VM.
Например, мы можем добавить подключение по паролю (а не только по ключу)

**копирование файлов**

с локалки на удалённую машину
```
scp LocalFile user@remotehost:directory/RemoteFile
```
с удалёнки на локалку
```
scp -r user@remotehost:directory/RemoteFolder LocalFolder 
```

# дз по bash
![[Pasted image 20220930161730.png]]


## переменные окружения

Можем переобозначить команду своим названием через
```
alias command_name=our_command
```
Но это временное решение на текующую баш сессию. Есть 2 решения
 - записать этот алияс в bashrc (файл, который запускается в начале каждой сессии баша)
 - добавить путь к бин. файлу в переменную PATH
 (: - сепаратор переменной PATH, добавляем директорию с нашим бинарником в PATH)
```
export PATH=$PA[[lecture_1_plan]]TH:our_dir
```

> Если 2 файла с одинаковым названиям лежат в PATH, то исполнится тот, чей путь лежит раньше.



![[Pasted image 20220930164258.png]]

## права доступа
![[Pasted image 20220930164523.png]]
![[Pasted image 20220930164804.png]]
![[Pasted image 20220930164900.png]]

## жёсткая и мягкая ссылки
файл ассоциируется не только с названием, но и с дескриптером. Дескриптор указывает на содержимое файла. Если последняя дескриптор (последняя жёсткая ссылка) удаляется, то содержимое файла становится бесполезным, поверх него можно писать.

Можно экономить память - создаём новую жёсткую ссылку на содержимое файла и можем читать с него как с нового файла с таким же содержимым, но не тратить лишнюю память.

> **жёсткие ссылки** хороши для дублирования ссылки на содержимое файла (для безопасности, например)
> **мягкие ссылки** хороши для работы с сетевыми студентами

- **жёсткая ссылка** может указывать на содержимое файлов текущей файловой системы
- **мягкая ссылка** может некоторое время указывать в никуда и ждать появления там сущности (например, внешнего жёсткого диска)

## wget

```
wget file_link
```

![[Pasted image 20221001092605.png]]


## линковка, c-make
### статическая линковка

> статическая библиотека пришивается в конец exe-шника
>  - можем использовать exe файл без каких либо дополнений
>  - раздувается размер exe файла

есть несколько lib_*.c файлов, которые мы хотим сложить в статическую библиотеку
 - создаём объектные файлы
```
gcc -c lib_*.c
```
 - собираем их в один файл
```
ar rc lib_name.a *list of files *.o *
```
 - линкуем наш main.c с нашей библиотекой
```
gcc main.c lib_name.a -o file_name.exe
```

### динамическая линковка

> динамическая линковка создаёт динамическую библиотеку, к которой может обращаться exe-шник при необходимости
>  - нужно правильно настраивать переменные окружения
>  - без динамической либы exe файл не будет запускаться

![[Pasted image 20221001093723.png]]

 - создаём объектные файлы
```
gcc -c foo.c
```
```
gcc -shared foo.o -o libfoo.so
echo $LD_LIBRARY_PATH
export LD_LIBRARY_PATH=$PWD
```
```
gcc -L$PWD main.c -lfoo.o -o try.exe
```

 - посмотреть от каких динамических библиотек зависит exe-шник
```
ldd try.exe
```


почитать про make file - habr habr makefile для самых маленьких

![[Pasted image 20221001094632.png]]
если исходные код зависимости не менялся, то он не пересобирается в объектник заново и не тратит время на это

много чего посмотреть в слайдах можно


# виртуализация

все исследования должны быть воспроизводимыми, должны фиксироваться все условия среды исполнения экспериментов

 - виртуальные машины для эмуляции нужной ОС - легко неэффективно использовать ресурсы машины + есть гейп по ресурсам из-за отжирания самой виртуальной машиной
 - переписывание переменных окружений среды (например, anaconda) - 90% достаточно
 - виртуализация через контейнеры - хорошая производительность
![[Pasted image 20221001115117.png]]

 - образ (image)
 - контейнер (container)


compose - выставление ресурсов на образы/контейнеры
базовые команды старта/запуска/остановки/сохранения/загрузки контейнеров, присоединения к ним и тд

есть такая штука, как Singularity - аналог докера, избавленный от некоторых изъянов


